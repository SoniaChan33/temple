/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from 'gill';
import {
  type ParsedBurnIncenseInstruction,
  type ParsedBuyIncenseInstruction,
  type ParsedCreateNftMintInstruction,
  type ParsedCreateTempleConfigInstruction,
  type ParsedInitUserInstruction,
} from '../instructions';

export const TEMPLE_PROGRAM_ADDRESS =
  '5iZVCAG6GAq3wdVL31Hy2eTybnUEYkgvnamqdQETAPUK' as Address<'5iZVCAG6GAq3wdVL31Hy2eTybnUEYkgvnamqdQETAPUK'>;

export enum TempleAccount {
  TempleConfig,
  UserState,
}

export function identifyTempleAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): TempleAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([27, 116, 7, 67, 209, 48, 108, 209])
      ),
      0
    )
  ) {
    return TempleAccount.TempleConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([72, 177, 85, 249, 76, 167, 186, 126])
      ),
      0
    )
  ) {
    return TempleAccount.UserState;
  }
  throw new Error(
    'The provided account could not be identified as a temple account.'
  );
}

export enum TempleInstruction {
  BurnIncense,
  BuyIncense,
  CreateNftMint,
  CreateTempleConfig,
  InitUser,
}

export function identifyTempleInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): TempleInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([192, 206, 18, 53, 21, 1, 239, 134])
      ),
      0
    )
  ) {
    return TempleInstruction.BurnIncense;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([158, 244, 18, 199, 55, 137, 6, 154])
      ),
      0
    )
  ) {
    return TempleInstruction.BuyIncense;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([220, 240, 28, 248, 182, 238, 138, 21])
      ),
      0
    )
  ) {
    return TempleInstruction.CreateNftMint;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([227, 91, 153, 89, 83, 215, 178, 242])
      ),
      0
    )
  ) {
    return TempleInstruction.CreateTempleConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([14, 51, 68, 159, 237, 78, 158, 102])
      ),
      0
    )
  ) {
    return TempleInstruction.InitUser;
  }
  throw new Error(
    'The provided instruction could not be identified as a temple instruction.'
  );
}

export type ParsedTempleInstruction<
  TProgram extends string = '5iZVCAG6GAq3wdVL31Hy2eTybnUEYkgvnamqdQETAPUK',
> =
  | ({
      instructionType: TempleInstruction.BurnIncense;
    } & ParsedBurnIncenseInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.BuyIncense;
    } & ParsedBuyIncenseInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.CreateNftMint;
    } & ParsedCreateNftMintInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.CreateTempleConfig;
    } & ParsedCreateTempleConfigInstruction<TProgram>)
  | ({
      instructionType: TempleInstruction.InitUser;
    } & ParsedInitUserInstruction<TProgram>);
